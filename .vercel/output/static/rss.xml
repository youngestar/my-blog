<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:version="2.0"><channel><title>💠 Youngestar&apos;s backyard</title><description>Youngestar 的个人博客, 希望是一个静悄悄但有意思的地方🌻</description><link>https://youngestar.vercel.app/</link><language>zh</language><item><title>网站自动更新配置尝试</title><link>https://youngestar.vercel.app/blog/auto-update-test/</link><guid isPermaLink="true">https://youngestar.vercel.app/blog/auto-update-test/</guid><description>关于我尝试完成网站自动更新配置的尝试过程</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://youngestar.vercel.app/blog/auto-update-test/&quot;&gt;https://youngestar.vercel.app/blog/auto-update-test/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;前段时间, 我在整理博客的时候, 发现博客手动更新比较麻烦, 特别是如果想把多个项目部署到多个不同的网站, 后续维护和更新需要大量的人工和时间成本&lt;/p&gt;
&lt;p&gt;但是我又想到了一些服务器比如 vercel 可以实现 github 部分提交后的自主更新, 那么它能做到我能不能做到呢? 带着这样的疑问, 我也进行了让我的博客自主更新功能的尝试&lt;/p&gt;
&lt;p&gt;(过程中用了不少 ai, 让它也帮我整理一些笔记吧)&lt;/p&gt;
&lt;!-- 网页自动更新功能（GitHub WebHook + 服务器自动拉取构建）实现过程笔记 --&gt;

&lt;h2&gt;前提检查&lt;/h2&gt;
&lt;p&gt;我的博客使用的是 京东云服务器 + 阿里云域名, 因为刚开始开的时候各种配置和比较参考不太仔细, 导致我现在感觉有点后悔...&lt;/p&gt;
&lt;p&gt;京东云是 2c2g 一个好拉胯的配置, 冲着首年 80 元左右的价格就下单了, 但是发现后续续费居然需要超过 400元/年 ... 实在是有点昂贵&lt;/p&gt;
&lt;p&gt;后面也才知道阿里云服务器可以申请学生优惠, 而且额度也不少, 下次试试吧&lt;/p&gt;
&lt;h2&gt;方案实践&lt;/h2&gt;
&lt;p&gt;上网搜索了一下后, 确定的方案是:&lt;/p&gt;
&lt;p&gt;利用 GitHub WebHook、宝塔 WebHook、Astro 构建工具和 Git，实现 “代码在 push 后，服务器自动拉取、构建并更新网页”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;大概就是:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;GitHub仓库配置WebHook&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器接收WebHook请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;宝塔WebHook插件执行脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;git pull拉取最新代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;pnpm run build构建Astro项目生成dist目录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nginx托管dist目录，网页自动更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看步骤好像很简单捏, 现在回想看来也感觉很简单, 但是其实实际操作时还是遇到了不少问题, 看与 ai 的对话记录, 又整理了一下, 大概地列了出来:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;初始化 GitHub WebHook 配置在 GitHub 仓库配置 WebHook，目标地址设为 .../hook（IP+HTTP）WebHook, 结果被提示 Invalid HTTP Response: 301（301 永久重定向）&lt;/p&gt;
&lt;p&gt;解决：服务器做了 80→443 强制跳转，把 WebHook 地址直接改成 https..., 走 443 端口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;解决 TLS 证书验证问题: 用 IP 配置 HTTPS WebHook, 结果:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;错误 1：x509: cannot validate certificate for IP because it doesn&amp;#39;t contain any IP SANs（证书缺少 IP 主题备用名称）&lt;/li&gt;
&lt;li&gt;错误 2：x509: certificate is valid for youngestar.top, not hook.youngestar.top（证书仅对主域名有效，对子域名无效）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决：给服务器 IP 绑定子域名 hook.youngestar.top, 并重新申请了包含 hook.youngestar.top 的 TLS 证书（覆盖子域名）, 将WebHook 地址改为 &lt;a href=&quot;https://hook.youngestar.top/hook&quot;&gt;https://hook.youngestar.top/hook&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;服务器配置 Git 环境在宝塔终端执行 git clone/git pull问题 1：git clone https://... 报 GnuTLS recv error (-110)（TLS 连接中断）
问题 2：git pull 报 fatal: detected dubious ownership（Git 安全检查，用户与目录所有者不一致&lt;/p&gt;
&lt;p&gt;解决：改用 SSH 协议克隆（git clone &lt;a href=&quot;mailto:git@github.com&quot;&gt;git@github.com&lt;/a&gt;:...），依赖已配置的 SSH 免密；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;验证 WebHook 触发逻辑配置宝塔 WebHook 插件，脚本包含 git pull + pnpm run build前期因路径问题报 404（Nginx 未映射 /hook 路径）&lt;/p&gt;
&lt;p&gt;解决：确认宝塔 WebHook 插件默认路径 /hook 有效，且脚本路径与项目目录一致&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;执行 Astro 项目构建执行 pnpm run build构建到 [build] Building static entrypoints... 时卡死，最终报 ELIFECYCLE exit code 137&lt;/p&gt;
&lt;p&gt;未解决😭：错误码 137 表示进程被 SIGKILL 强制终止，最常见的原因是系统内存不足触发 oom-killer, 多半是因为配置过低爆掉了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后我一点点地攻克了各种问题, 结果发现最后还是跑不动... 最后我自己在各种检查后想起来手动在服务器上跑一下预设的命令试试, 大概是这些:&lt;/p&gt;
&lt;p&gt;cd /www/wwwroot/youngestar.top # 进入项目目录&lt;/p&gt;
&lt;p&gt;git pull origin main # 拉取最新代码&lt;/p&gt;
&lt;p&gt;pnpm install # 安装新增依赖（可选）&lt;/p&gt;
&lt;p&gt;pnpm run build # 构建生成dist目录&lt;/p&gt;
&lt;p&gt;systemctl reload nginx # 重启Nginx（可选，刷新缓存）&lt;/p&gt;
&lt;p&gt;然后在 pnpm install 的时候就有些卡顿, 最后 pnpm run build 的时候理所应当地反复报错 137 或者直接卡死了, 看来想要 2c2g 服务器直接用来打包还是有点太奢侈了&lt;/p&gt;
&lt;p&gt;检查到最后, 想到这个我买的服务器实在有点拉胯, 配置过于低下, 续费又贵得很夸张, 就丧失了继续折腾的兴趣, 我的博客以后还是手动更新维护着吧&lt;/p&gt;
&lt;p&gt;不过其实在过程中还是学到了不少东西, 比如认识了 github 和 宝塔的钩子, 用着确实很方便(后面发现有一些项目也在使用 github 的钩子用于在 push 前验证代码可靠性之类的), 还进一步地了解了服务器的配置&lt;/p&gt;
&lt;p&gt;感觉免费的服务器并不比我的低配小服务器差多少, 甚至有的免费服务器也能做到在国内直接访问(例如 InfinityFree), 感觉以后可以多试试&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下次买云服务器再也不会只图首年低价了 T_T&lt;/em&gt;&lt;/p&gt;
</content:encoded><dc:creator>youngestar-backyard</dc:creator><pubDate>Thu, 28 Aug 2025 16:00:00 GMT</pubDate></item><item><title>在艳阳下</title><link>https://youngestar.vercel.app/blog/about-my-life/</link><guid isPermaLink="true">https://youngestar.vercel.app/blog/about-my-life/</guid><description>关于我暑假的零散小记和学年小结</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://youngestar.vercel.app/blog/about-my-life/&quot;&gt;https://youngestar.vercel.app/blog/about-my-life/&lt;/a&gt;&lt;/blockquote&gt; &lt;p&gt;我发现我又好久没有写博客了, 主要还是感觉技术类知识也琐碎, 不知道写点什么... 今天半夜手机没电充电, 无事可做, 就随便补点生活博客吧.&lt;/p&gt;
&lt;p&gt;感觉暑假过得好懒散, 回家后被一种随意, 轻松, 安逸的氛围包裹, 感觉天天就搞那么一点点事情, 剩下的时间吃, 耍, 睡翻来覆去和那什么 pig 一样... 但是躺平的快乐是真的, 每天躺在床上望着天花板, 握着手机再想点消遣总是能给人带来难以言喻的舒适感觉.&lt;/p&gt;
&lt;p&gt;安逸的时光真的好快, 一晃眼暑假就已经过了一半, 换成上学等量时间我不知道要在学校翻来覆去挣扎折磨好久(夸张修辞见谅哈). 同时有时晚上外出散步大脑空下来又切身体会到了时间的紧迫, 发现自己要学, 想做, 该完成的事情实在太多, 在家中快乐的时间其实对这些任务无济于事, 也许我应该选择早点返校吧, 早点调整一下状态, 也该真正地规划一下动向了.&lt;/p&gt;
&lt;p&gt;也发现自己不再是新生了, 失去了这个 buff 后也是切身体会到了时间紧促的压力和有事未做的责任. 我还是觉得自己在这一年中还算做了不少事, 也许其实应该做得更多更好? 但有时我想像现在这样弯弯曲曲地走着才是我真实的生活吧.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;8.25 附: 今日返校, 没想到距离我写这条博客又是好久了2333, 玩得很爽, 接下来又要回归日常了, 心里有一些小目标, 希望能完成吧&lt;/em&gt;&lt;/p&gt;
</content:encoded><dc:creator>youngestar-backyard</dc:creator><pubDate>Thu, 31 Jul 2025 16:00:00 GMT</pubDate></item><item><title>正则表达式基础笔记</title><link>https://youngestar.vercel.app/blog/regex-note/</link><guid isPermaLink="true">https://youngestar.vercel.app/blog/regex-note/</guid><description>感觉正则表达式很容易忘记, 所以写了一篇小笔记记录一些知识点</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://youngestar.vercel.app/blog/regex-note/&quot;&gt;https://youngestar.vercel.app/blog/regex-note/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;正则表达式&lt;/h2&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;个人感觉正则表达式用得比较多, 但是又很容易忘记, 所以写了一篇小笔记记录一些知识点, 以下内容部分来自 AI , 但是经过了我滴收集与整合和修订, 如果有误请指正哦😗&lt;/p&gt;
&lt;h3&gt;JS 正则表达式（RegEx）极简核心知识&lt;/h3&gt;
&lt;h4&gt;&lt;strong&gt;一、定义&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;正则表达式&lt;/strong&gt;是一种用于&lt;strong&gt;字符串模式匹配&lt;/strong&gt;的强大工具，可快速搜索、替换、验证符合特定规则的文本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心目标&lt;/strong&gt;：用简洁的语法描述复杂的字符串规则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语法形式&lt;/strong&gt;：
p&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在代码中通常用字符串表示（需注意转义符），例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JavaScript：&lt;code&gt;const regex = /pattern/flags&lt;/code&gt;（字面量形式）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;二、核心语法：3 类基础符号&lt;/strong&gt;&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;类别&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;符号 / 语法&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;示例与含义&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;字符匹配&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;普通字符、&lt;code&gt;\.&lt;/code&gt;（任意单个字符）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt; 匹配 &lt;code&gt;a&lt;/code&gt;；&lt;code&gt;\.&lt;/code&gt; 匹配点号；&lt;code&gt;\d&lt;/code&gt; 匹配数字（等价于 &lt;code&gt;[0-9]&lt;/code&gt;）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;量词&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;（0 + 次）、&lt;code&gt;+&lt;/code&gt;（1 + 次）、&lt;code&gt;?&lt;/code&gt;（0 或 1 次）、&lt;code&gt;{n}&lt;/code&gt;（n 次）、&lt;code&gt;{n,m}&lt;/code&gt;（n 到 m 次）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a+&lt;/code&gt; 匹配 1 个或多个 &lt;code&gt;a&lt;/code&gt;；&lt;code&gt;\d{3}&lt;/code&gt; 匹配 3 位数字；&lt;code&gt;[A-Za-z]?&lt;/code&gt; 匹配 0 或 1 个字母。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;边界符&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;（行首）、&lt;code&gt;$&lt;/code&gt;（行尾）、&lt;code&gt;\b&lt;/code&gt;（单词边界）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^hello&lt;/code&gt; 匹配以 &lt;code&gt;hello&lt;/code&gt; 开头的字符串；&lt;code&gt;world$&lt;/code&gt; 匹配以 &lt;code&gt;world&lt;/code&gt; 结尾的字符串。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;h4&gt;&lt;strong&gt;三、常用符号详解&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;元字符（特殊功能符号）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;[]&lt;/code&gt;：字符类，匹配&lt;strong&gt;其中任意一个字符&lt;/strong&gt;(注意是一个字符哦) 。&lt;/p&gt;
&lt;p&gt;✅ &lt;code&gt;[abc]&lt;/code&gt; 匹配 &lt;code&gt;a&lt;/code&gt;、&lt;code&gt;b&lt;/code&gt;、&lt;code&gt;c&lt;/code&gt;；&lt;code&gt;[A-Za-z]&lt;/code&gt; 匹配任意字母；&lt;code&gt;[^\d]&lt;/code&gt; 匹配非数字（&lt;code&gt;^&lt;/code&gt; 在 &lt;code&gt;[]&lt;/code&gt; 内表示取反）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;|&lt;/code&gt;：逻辑或，匹配左右任意一侧。&lt;/p&gt;
&lt;p&gt;✅ &lt;code&gt;cat|dog&lt;/code&gt; 匹配 &lt;code&gt;cat&lt;/code&gt; 或 &lt;code&gt;dog&lt;/code&gt;；&lt;code&gt;https?&lt;/code&gt; 匹配 &lt;code&gt;http&lt;/code&gt; 或 &lt;code&gt;https&lt;/code&gt;（&lt;code&gt;s?&lt;/code&gt; 表示 &lt;code&gt;s&lt;/code&gt; 可选）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;()&lt;/code&gt;：分组 / 捕获，用于提取匹配内容或优先处理逻辑。&lt;/p&gt;
&lt;p&gt;✅ &lt;code&gt;(ab)+&lt;/code&gt; 匹配 &lt;code&gt;ab&lt;/code&gt; 重复多次；&lt;code&gt;(\d{3})-(\d{4})&lt;/code&gt; 捕获两组数字（如 &lt;code&gt;123-4567&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;转义字符&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;用 &lt;code&gt;\&lt;/code&gt; 转义特殊符号，使其作为普通字符匹配。&lt;/p&gt;
&lt;p&gt;✅ &lt;code&gt;\+&lt;/code&gt; 匹配加号 &lt;code&gt;+&lt;/code&gt;；&lt;code&gt;\(&lt;/code&gt; 匹配左括号 &lt;code&gt;(&lt;/code&gt;；&lt;code&gt;\\&lt;/code&gt; 匹配反斜杠 &lt;code&gt;\&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;简写字符类&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;等价于&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[^0-9]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单词字符（字母、数字、下划线）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[\t\n\r\f\v]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;空白字符（空格、换行等）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;strong&gt;四、高级特性&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;贪婪与非贪婪匹配&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;贪婪模式&lt;/strong&gt;（默认）：尽可能多匹配，如 &lt;code&gt;a.*b&lt;/code&gt; 匹配 &lt;code&gt;a...b&lt;/code&gt; 中最长的部分。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非贪婪模式&lt;/strong&gt;：加 &lt;code&gt;?&lt;/code&gt;，尽可能少匹配，如 &lt;code&gt;a.*?b&lt;/code&gt; 匹配最短的 &lt;code&gt;a...b&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;断言（零宽匹配）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;正向前瞻&lt;/strong&gt;：&lt;code&gt;(?=pattern)&lt;/code&gt;，匹配 &lt;code&gt;pattern&lt;/code&gt; 前面的内容（不消耗字符）。&lt;/p&gt;
&lt;p&gt;✅ &lt;code&gt;abc(?=def)&lt;/code&gt; 匹配 &lt;code&gt;abc&lt;/code&gt; 且后面是 &lt;code&gt;def&lt;/code&gt;（如 &lt;code&gt;abcdef&lt;/code&gt; 中的 &lt;code&gt;abc&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;负向前瞻&lt;/strong&gt;：&lt;code&gt;(?!pattern)&lt;/code&gt;，匹配 &lt;code&gt;pattern&lt;/code&gt; 前面&lt;strong&gt;不是&lt;/strong&gt;的内容。&lt;/p&gt;
&lt;p&gt;✅ &lt;code&gt;abc(?!def)&lt;/code&gt; 匹配 &lt;code&gt;abc&lt;/code&gt; 且后面&lt;strong&gt;不是&lt;/strong&gt; &lt;code&gt;def&lt;/code&gt;（如 &lt;code&gt;abcfg&lt;/code&gt; 中的 &lt;code&gt;abc&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;反向引用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;()\n&lt;/code&gt;（n 为分组序号），引用之前分组匹配的内容。&lt;/p&gt;
&lt;p&gt;✅ &lt;code&gt;(\d)\1&lt;/code&gt; 匹配两个连续相同数字（如 &lt;code&gt;11&lt;/code&gt;、&lt;code&gt;22&lt;/code&gt;）；&lt;code&gt;(ab)\1&lt;/code&gt; 匹配 &lt;code&gt;abab&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;strong&gt;五、典型应用场景&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;搜索与提取&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;从文本中提取邮箱：&lt;code&gt;\b[\w.-]+@[\w.-]+\.\w{2,}\b&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;匹配 URL：&lt;code&gt;https?://(www\.)?[a-zA-Z0-9-]+\.[a-zA-Z]{2,}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替换文本&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;去除字符串中的所有数字：&lt;code&gt;str.replace(/\d+/g, &amp;#39;&amp;#39;)&lt;/code&gt;（&lt;code&gt;g&lt;/code&gt; 为全局匹配标志）。&lt;/li&gt;
&lt;li&gt;将驼峰命名转为下划线：&lt;code&gt;str.replace(/([A-Z])/g, &amp;#39;_$1&amp;#39;).toLowerCase()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;验证输入&lt;/strong&gt;&lt;ul&gt;
&lt;li&gt;手机号（中国）：&lt;code&gt;^1[3-9]\d{9}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;密码（8-20 位，含字母 + 数字）：&lt;code&gt;^(?=.*\d)(?=.*[A-Za-z])[0-9A-Za-z]{8,20}$&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;strong&gt;六、注意事项&lt;/strong&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;转义的双重性&lt;ul&gt;
&lt;li&gt;如果使用正则字符串，需额外转义（例 :&lt;code&gt;&amp;quot;\\d&amp;quot;&lt;/code&gt; 表示正则中的 &lt;code&gt;\d&lt;/code&gt;）(还是建议使用正则字面量比如 /\d/ )。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;性能陷阱&lt;ul&gt;
&lt;li&gt;避免过度使用贪婪匹配和复杂分组，防止回溯爆炸（如 &lt;code&gt;.*&lt;/code&gt; 后接复杂断言）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试优先&lt;ul&gt;
&lt;li&gt;用在线工具（如 &lt;a href=&quot;https://regexr-cn.com/&quot;&gt;RegExr&lt;/a&gt;、&lt;a href=&quot;https://regexlearn.com/zh-cn/playground&quot;&gt;Regex Learn&lt;/a&gt;）验证正则逻辑，再嵌入代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;strong&gt;七、外部学习网站&lt;/strong&gt;&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://regexr-cn.com/&quot;&gt;Regexr 中文网&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://regexlearn.com/zh-cn/learn&quot;&gt;Regexr Learn&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zh.javascript.info/regular-expressions&quot;&gt;现代 JavaScript 教程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;strong&gt;八、附表&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;字符匹配&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;匹配结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配任意单个字符（除换行）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a.b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;acb&lt;/code&gt;, &lt;code&gt;a1b&lt;/code&gt;, &lt;code&gt;a@b&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配数字（等价于 &lt;code&gt;[0-9]&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\d{3}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;123&lt;/code&gt;, &lt;code&gt;007&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配非数字（等价于 &lt;code&gt;[^0-9]&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\D+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;abc&lt;/code&gt;, &lt;code&gt;@!&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配单词字符（字母、数字、下划线）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\w{5}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;hello&lt;/code&gt;, &lt;code&gt;a1_b2&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配非单词字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\W+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;@# $&lt;/code&gt;, &lt;code&gt;空格&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配空白字符（空格、制表符、换行等）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a\sb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a b&lt;/code&gt;, &lt;code&gt;a\tb&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配非空白字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\S+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;abc&lt;/code&gt;, &lt;code&gt;123&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;转义特殊字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;.&lt;/code&gt;（句点本身）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;字符类（&lt;code&gt;[]&lt;/code&gt;）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;匹配结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[ ]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配方括号内的任意字符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[aeiou]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;e&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[^ ]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;否定字符类（不匹配）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[^0-9]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;空格&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义范围&lt;/td&gt;
&lt;td&gt;&lt;code&gt;[a-z]&lt;/code&gt;, &lt;code&gt;[0-9A-F]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;b&lt;/code&gt;, &lt;code&gt;5&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;或（在方括号外使用）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cat|dog&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;dog&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;注: “ - ” 符号前后范围依据于 ASCII 码值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;量词（重复匹配）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;匹配结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;零次或多次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ab*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一次或多次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ab+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abbb&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;零次或一次（可选）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;colou?r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;color&lt;/code&gt;, &lt;code&gt;colour&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;精确重复 n 次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\d{3}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;123&lt;/code&gt;, &lt;code&gt;000&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{n,}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;至少重复 n 次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a{2,}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;aa&lt;/code&gt;, &lt;code&gt;aaaa&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重复 n 到 m 次&lt;/td&gt;
&lt;td&gt;&lt;code&gt;a{2,4}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;aa&lt;/code&gt;, &lt;code&gt;aaa&lt;/code&gt;, &lt;code&gt;aaaa&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;锚点（位置匹配）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;匹配结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字符串开头&lt;/td&gt;
&lt;td&gt;&lt;code&gt;^Hello&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Hello world&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字符串结尾&lt;/td&gt;
&lt;td&gt;&lt;code&gt;world$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Hello world&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单词边界&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\bcat\b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;The cat runs&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非单词边界&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\Bcat\B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;abcatde&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;分组与引用&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;匹配结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;( )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;捕获组&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(ab)+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abab&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;反向引用捕获组&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(\d)\1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;11&lt;/code&gt;, &lt;code&gt;22&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?: )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非捕获组（不存储）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?:ab)+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;ab&lt;/code&gt;, &lt;code&gt;abab&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;断言（零宽匹配）&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;匹配结果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?= )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正向先行断言（后面必须是）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\d+(?= dollars)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;100&lt;/code&gt; in &lt;code&gt;100 dollars&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?! )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;负向先行断言（后面不能是）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;\d+(?! dollars)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;100&lt;/code&gt; in &lt;code&gt;100 yen&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;= )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正向后行断言（前面必须是）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;=\$)\d+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;100&lt;/code&gt; in &lt;code&gt;$100&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;! )&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;负向后行断言（前面不能是）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;!\$)\d+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;100&lt;/code&gt; in &lt;code&gt;¥100&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;标志符(附于正则表达式后, 影响搜索结果)&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;示例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;全局匹配（查找所有）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/\d/g&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;i&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;忽略大小写&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/apple/i&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多行模式（&lt;code&gt;^&lt;/code&gt; 和 &lt;code&gt;$&lt;/code&gt; 匹配行首 / 行尾）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/^line/m&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;允许 &lt;code&gt;.&lt;/code&gt; 匹配换行符&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/a.b/s&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;u&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unicode 模式&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/\u{1F600}/u&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;粘连模式（从 &lt;code&gt;lastIndex&lt;/code&gt; 开始匹配）&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/\d/y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;方法对比&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;返回值类型&lt;/th&gt;
&lt;th&gt;是否含捕获组&lt;/th&gt;
&lt;th&gt;是否全局匹配&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;regex.test(str)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;regex.exec(str)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数组或 &lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是（需 &lt;code&gt;g&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;str.match(regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数组或 &lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;部分情况&lt;/td&gt;
&lt;td&gt;是（需 &lt;code&gt;g&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;str.matchAll(regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;迭代器&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;必须 &lt;code&gt;g&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;str.search(regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;位置（&lt;code&gt;number&lt;/code&gt;）&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;str.replace(regex, replacement)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;替换后的字符串&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是（需 &lt;code&gt;g&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;str.split(regex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;em&gt;感觉整理后还是学到了不少东西哦, 希望以后能多用到&lt;/em&gt;&lt;/p&gt;
</content:encoded><dc:creator>youngestar-backyard</dc:creator><pubDate>Wed, 21 May 2025 16:00:00 GMT</pubDate></item><item><title>域名与服务器</title><link>https://youngestar.vercel.app/blog/about-my-web/</link><guid isPermaLink="true">https://youngestar.vercel.app/blog/about-my-web/</guid><description>我与我的域名与我的服务器</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://youngestar.vercel.app/blog/about-my-web/&quot;&gt;https://youngestar.vercel.app/blog/about-my-web/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这篇文章距离上一篇已经比较久了,原因是我这段时间一直在处理域名和服务器相关的事情.在搞完博客后我先部署到了vercel上(话说vercel真挺方便的),然后还是总觉得一个博客老是被被墙还是不太够劲,所以就想着先搞个服务器,然后又觉得服务器都有了,应该再搞个域名...之后就又杂七杂八搞了一堆,好像还是花了不少时间.&lt;/p&gt;
&lt;p&gt;所以我还是顺带整篇文章吧😽&lt;/p&gt;
&lt;h3&gt;关于域名&lt;/h3&gt;
&lt;p&gt;域名是在阿里云上买的,其实我对域名和服务器的考察还是主要基于性价比,主要我没啥马内...&lt;/p&gt;
&lt;p&gt;想了一下选了&lt;code&gt;.top&lt;/code&gt;作为后缀,现在想来好像是有一点奇怪,毕竟便宜嘛,将就一下吧.&lt;/p&gt;
&lt;p&gt;域名这块主要做了解析和备案的工作,主要就是将域名指向服务器IP地址和使域名合法化嘛.这一块还是备案有一些些麻烦,不过难度也不算大.&lt;/p&gt;
&lt;h3&gt;关于服务器&lt;/h3&gt;
&lt;p&gt;服务器则是京东云,我先和阿里云的服务器对比了一下加个,还是有点傻不拉几地喜滋滋抢了一个第一年所谓打折的服务器,后面才了解到相关的常见的第一年半价第二年天价的套路,不过其实还好啦.京东云相比之下确实会更便宜一些,就是用着有点卡卡的.&lt;/p&gt;
&lt;p&gt;后面将博客部署到服务器的过程中倒是出了不少问题.我没有做太多准备就开始蛮干,一问 ai 直接生啃了一些 linux 基础操作对照着它给的步骤一步一步暴力推近, 结果的惨烈可想而知,我做到最后一步回头审视自己处处出错的💩山后真是&amp;quot;拔剑四顾心茫然&amp;quot;...最后在询问了小伙伴及上网查询后决定从京东服务器自带的宝塔面板入手从头再来.&lt;/p&gt;
&lt;p&gt;这一部分还是算比较顺利,有了宝塔面板是真的方便了许多,但是我在流利地设置了新建了站点,配置了防火墙,搞了搞 nginx 后又绝望地发现虽然能正常登录网址但页面仍然是 nginx
默认页面(说实话现在想想应该能比较简单地排查出是 nginx 配置的问题),然后我就从各种 ai 还有网上查找资料和命令测试尝试排查错误,一样一样地到处排查结果毛也没有发现...
(当时忘了截个图记录一下了,先欠着吧)&lt;/p&gt;
&lt;p&gt;我磕磕绊绊地隔几天就排查下服务器,最后在对 ai 提示词不断的细化和疯狂地追问下通过 nginx -T 这个神奇的命令破了案---我的 nginx 配置文件有问题,应该是我之前自己胡乱试错时将 nginx 与某个默认配置文件链接在了一起,后来我做了一些清除操作后最终还是成功了✌️.在部署了 SSL 证书后就可以使用了.&lt;/p&gt;
&lt;h3&gt;待办&lt;/h3&gt;
&lt;p&gt;感觉评论区还是加载好慢! 应该也要挂到服务器上的, 但是太麻烦了, 先挂载在 vercel 上吧, 以后再来搞搞&lt;/p&gt;
&lt;p&gt;&lt;em&gt;服务器还是有点意思哈,以后多搞搞,不然对不起花的马内&lt;/em&gt;&lt;/p&gt;
</content:encoded><dc:creator>youngestar-backyard</dc:creator><pubDate>Wed, 07 May 2025 16:00:00 GMT</pubDate></item><item><title>博客搭建成功</title><link>https://youngestar.vercel.app/blog/about-my-blog/</link><guid isPermaLink="true">https://youngestar.vercel.app/blog/about-my-blog/</guid><description>关于我的博客的小故事和我想说的话</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://youngestar.vercel.app/blog/about-my-blog/&quot;&gt;https://youngestar.vercel.app/blog/about-my-blog/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;博客搭建成功&lt;/h2&gt;
&lt;p&gt;当我写下这篇文章时, 代表我的博客终于要搭建完成了. 在看到不少佬的 so cooool 的博客后, 觉得有博客这件事蛮帅, 于是便临时起意想搞个自己的博客. 现在写着文章, 才发现自己写点东西磕磕绊绊的, 写过的作文都还给老师了, 哈哈.&lt;/p&gt;
&lt;p&gt;开始也是雄心壮志想搞个自己的框架, 后来发现自己是只癞蛤蟆想吃天鹅肉... 后面挑了好久, 选择了大家看到的这个博客框架(看着还是挺不错嘛). 从起意到准备到尝试到实践, 前前后后可能也花了 20 天左右? 途中遇到了不少小问题, 但综合来说还是没有自己预想的那么困难. 希望以后能在博客上多更新一些东西吧(看到我断更了请踢我谢谢). 做博客的过程也见识了不少的新技术, 总体来说还是挺有意思的.&lt;/p&gt;
&lt;p&gt;现在写点感想?&lt;/p&gt;
&lt;p&gt;单从作息和管束来讲, 大学就是爽哈. 每天这这那那, 然后感觉就像哦哦啊啊呃呃噢噢噢哦哦...... 我以前就在想: 如果以后能做什么电什么信息什么实验巴拉巴拉之类的专业和工作一定会很帅和很爽, 但说实话是阴差阳错进入了计算机的领域; 阴差阳错捡起了我手中的笔记本然后估计再也放不开; 阴差阳错发现自己已经走到了这里, 回头一望发现已经走了挺远的路但是还有更远更远的路要走...... 也许电脑和代码是一种挺有趣, 挺时髦, 挺 cool 的玩意? 反正学着好像没有高数那么要我命, 哈哈.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;--&amp;quot;长者有云: 世上有一颗高高的树, 上面挂满了人&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;希望这个博客能见证我的成长, 也希望我能带着这个 blog 尽量地走下去... 在这个 backyard 中, 我尽力地写一些我的技术的 “小巧思” 吧, 如果兴致来了也有可能会记录自己的生活或者写一些呜呜噫噫啊啊的小故事? 谁知道呢.&lt;/p&gt;
&lt;p&gt;希望能收集各位大佬的友链! 希望你们主动联系我, 不要逼我求你们😗. 如果有哪位 bro 或者 sis 想借我的博客发一些东西, 也可以联系我哦.&lt;/p&gt;
&lt;p&gt;可以在留言区里留言! 写一些 想对我 | 想对这个博客 说的话或者提的建议, 也许你也可以通过上面留下的联系方式联系我, 咱们偷偷地唠两句?&lt;/p&gt;
&lt;p&gt;最后再介绍一下这个博客:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hi, I&amp;#39;m Youngestar!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里是我的后院&lt;/p&gt;
&lt;p&gt;是一名前端的开发者和学习者, 目前还是技术小白&lt;/p&gt;
&lt;p&gt;希望能做一个很有趣的人, 希望能一直向前进&lt;/p&gt;
&lt;p&gt;与君共勉✌️&lt;/p&gt;
&lt;p&gt;&lt;em&gt;后记: 自以为整完博客就离成功不远了, 结果部署出了好多好多问题...花了好长好长时间...&lt;/em&gt;&lt;/p&gt;
</content:encoded><dc:creator>youngestar-backyard</dc:creator><pubDate>Wed, 09 Apr 2025 16:00:00 GMT</pubDate></item><item><title>React 文档笔记</title><link>https://youngestar.vercel.app/blog/react-text-note/</link><guid isPermaLink="true">https://youngestar.vercel.app/blog/react-text-note/</guid><description>前段时间阅读 React 官方文档时, 顺手记录了一些个人认为比较重要的知识点作为笔记</description><content:encoded>&lt;blockquote&gt;This rendering was automatically generated by Frosti Feed and may have formatting issues. For the best experience, please visit: &lt;a href=&quot;https://youngestar.vercel.app/blog/react-text-note/&quot;&gt;https://youngestar.vercel.app/blog/react-text-note/&lt;/a&gt;&lt;/blockquote&gt; &lt;h2&gt;React 文档笔记&lt;/h2&gt;
&lt;p&gt;前段时间阅读 React 官方文档时, 顺手记录了一些个人认为比较重要的知识点作为笔记, 都是比较基础的知识&lt;br/&gt;
(如果发现有误, 请联系我)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;style 写法: &lt;code&gt;{{  }}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;tailwind 与 组件库容易冲突, 支持 tailwind 的组件库: heroui(最好使用 next.js 在搭建项目时直接一起搭建)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;\export default 默认导出, export 具名导出, 有很多区别, 可以自己思考一下&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;建议将 props 解构使用并提供默认值(默认值只会对 undefined 生效)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;大量组件渲染, 涉及变动时建议添加 key 进行绑定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;列表渲染组件 map 返回 tsx(同样记得加 key) 或者 fliter 返回 过滤后数组 (=&amp;gt; 直接少量数据返回 或者 =&amp;gt; {return ...})&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 及 &lt;code&gt;&amp;lt;/&amp;gt;&lt;/code&gt; 不可添加 key, 此时替换为 &lt;code&gt;&amp;lt;Fragment&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;/ Fragment&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;组件不应当更改任何值, 只负责进行渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;命名惯例: 按照惯例，通常将事件处理程序命名为 &lt;code&gt;handle&lt;/code&gt;，后接事件名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;某些浏览器事件具有与事件相关联的默认行为, 例:点击 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 表单内部的按钮会触发表单提交事件，默认情况下将重新加载整个页面, 应当使用 e.preventDefault() 进行阻止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;e.stopPropagation()&lt;/code&gt; 阻止冒泡&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;{ }&lt;/code&gt; 内部应当传递事件而非函数调用, 实际上, 传递函数调用的话将在每次渲染时被运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://zh-hans.react.dev/reference/react/useState&quot;&gt;&lt;code&gt;useState&lt;/code&gt;&lt;/a&gt; 最终提供功能: &lt;strong&gt;State 变量&lt;/strong&gt; 用于保存渲染间的数据, &lt;strong&gt;State setter 函数&lt;/strong&gt; 更新变量并触发 React 再次渲染组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hooks 依托于一个稳定的调用顺序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react 渲染机制: 初次渲染根组件, 之后渲染 被更新的组件 及 其子组件( 递归过程 ), 在开发环境中，React 会在组件首次挂载后立即重新挂载一次, 以便于发现各种问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;state setter 处理机制: react 将会收集 该事件处理函数 中的所有更新(需要重新渲染组件的操作), 并在该函数执行完毕后 &lt;strong&gt;一次性&lt;/strong&gt; 合并更新并触发重新渲染, 在 react 18 前, 异步函数中的所有更新将被 &lt;strong&gt;立刻执行&lt;/strong&gt; ,但在 react 18 后, 异步函数中的更新同样将被收集并合并更新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用函数式更新可以在末尾集中运行时, 每次运行后及时更新 state 的值(但是还是可以被后面的赋值给覆盖)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import { useState } from &amp;#39;react&amp;#39;;

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    &amp;lt;&amp;gt;
      \&amp;lt;h1&amp;gt;{number}\&amp;lt;/h1&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; {
        setNumber(number + 5);
        setNumber(n =&amp;gt; n + 1);
        setNumber(42);
      }}&amp;gt;增加数字\&amp;lt;/button&amp;gt;
    &amp;lt;/&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;更新步骤&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;队列中的值变化&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;初始值&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;渲染时的初始状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setNumber(0 + 5)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;计划更新为 &lt;code&gt;5&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;基于当前值 &lt;code&gt;0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setNumber(n =&amp;gt; n + 1)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;计划更新为 &lt;code&gt;6&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;基于前一次队列值 &lt;code&gt;5&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;code&gt;setNumber(42)&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;覆盖为 &lt;code&gt;42&lt;/code&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;直接赋值，忽略前序计算结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;最终结果&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;&lt;strong&gt;&lt;code&gt;42&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;最后一次更新覆盖所有前序值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&quot;19&quot;&gt;
&lt;li&gt;&lt;p&gt;使用展开语法 &lt;code&gt;[...a, b]&lt;/code&gt; 或 &lt;code&gt;{ ...a, b:&amp;#39;b&amp;#39;}&lt;/code&gt; 可以进行数组或对象的快速合并, 在对象中使用 [ ] 可以做到动态命名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;useImmer&lt;/code&gt; 代替 &lt;code&gt;useState&lt;/code&gt; 可以更快和更直接地更新对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;react 中推荐与不推荐使用的数组方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;避免使用 (会改变原始数组)&lt;/th&gt;
&lt;th&gt;推荐使用 (会返回一个新数组） )&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;添加元素&lt;/td&gt;
&lt;td&gt;&lt;code&gt;push&lt;/code&gt;，&lt;code&gt;unshift&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;concat&lt;/code&gt;，&lt;code&gt;[...arr]&lt;/code&gt; 展开语法（&lt;a href=&quot;https://zh-hans.react.dev/learn/updating-arrays-in-state#adding-to-an-array&quot;&gt;例子&lt;/a&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除元素&lt;/td&gt;
&lt;td&gt;&lt;code&gt;pop&lt;/code&gt;，&lt;code&gt;shift&lt;/code&gt;，&lt;code&gt;splice&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;filter&lt;/code&gt;，&lt;code&gt;slice&lt;/code&gt;（&lt;a href=&quot;https://zh-hans.react.dev/learn/updating-arrays-in-state#removing-from-an-array&quot;&gt;例子&lt;/a&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;替换元素&lt;/td&gt;
&lt;td&gt;&lt;code&gt;splice&lt;/code&gt;，&lt;code&gt;arr[i] = ...&lt;/code&gt; 赋值&lt;/td&gt;
&lt;td&gt;&lt;code&gt;map&lt;/code&gt;（&lt;a href=&quot;https://zh-hans.react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array&quot;&gt;例子&lt;/a&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;排序&lt;/td&gt;
&lt;td&gt;&lt;code&gt;reverse&lt;/code&gt;，&lt;code&gt;sort&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;先将数组复制一份（&lt;a href=&quot;https://zh-hans.react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array&quot;&gt;例子&lt;/a&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;22. 对象并不是 &lt;em&gt;真的&lt;/em&gt; 位于数组“内部”, 可能他们在代码中看起来像是在数组“内部”. 同样 对象并不是真的嵌套, 只是看起来像嵌套&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;ol start=&quot;23&quot;&gt;
&lt;li&gt;&lt;p&gt;state 设置原则: &lt;strong&gt;使 state 易于更新而不引入错误&lt;/strong&gt; , 例: 少使用 Boolean 类型的 state, 而将其直接命名为各种状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始 state 命名惯例: 以 &lt;code&gt;initial&lt;/code&gt; 或 &lt;code&gt;default&lt;/code&gt; 开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;state 不建议多层嵌套, 建议扁平化处理, 使用 递归 对子元素进行渲染和使用 递归 对子元素进行处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以在组件中间添加 JSX 等内容, 将作为 children 特殊属性传给组件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 react 中, **UI 树中 **相同位置的相同组件会被视为同一个组件, state 会被保留下来, 而在一般情况下, 组件被销毁后, state 会被重置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 key 可以很方便地独立组件并重置 state, 想要在这种情况下保留 state 的话, 请使用状态提升&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;复杂情况下 useState 的代替: useReducer, reducer 可以整合状态逻辑, 增加代码的可理解性和易维护性&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;给予初始值: initailTasks, 集中处理函数: tasksReducer, 初始值及后续更改后的值将被封装在 tasks 中, 使用 dispatch 将触发 tasksReducer 函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;function tasksReducer(tasks, action) {
          switch (action.type) {
            case &amp;#39;added&amp;#39;: {
              return ...;
            }
            case &amp;#39;changed&amp;#39;: {
              return ...;
            case &amp;#39;deleted&amp;#39;: {
              return ...;
            }
            default: {
              throw Error(&amp;#39;未知 action: &amp;#39; + action.type);
            }
          }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tasksReducer 函数中集中处理 tasks 变化, 通过 switch 来对应 action 中传递的各种情况并 return 处理后的 tasks(使用 action 中的参数对 tasks 进行修改), 还可以使用 default 进行意外的错误处理&lt;/p&gt;
&lt;p&gt;在对应情况的函数中, 使用 &lt;code&gt;dispatch(action)&lt;/code&gt; 分发 action 触发 tasksReducer 函数, 便会根据 dispatch 中 type 的值使用对应的 switch 进行 tasks 的对应处理&lt;/p&gt;
&lt;ol start=&quot;30&quot;&gt;
&lt;li&gt;&lt;p&gt;使用 context 代替 props 层层透传&lt;/p&gt;
&lt;p&gt;首先, 创建一个 context (一般在新的文件中),&lt;/p&gt;
&lt;p&gt;例: &lt;code&gt;export const LevelContext = createContext(1);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;creatContext()&lt;/code&gt; 中的为初始值, LevelContext 为创建后的 context 名&lt;/p&gt;
&lt;p&gt;然后, 在需要应用的组件(注意: 指最终接收和应用 context 的子组件)中导入 LevelContext ,&lt;/p&gt;
&lt;p&gt;使用 useContext 将它赋值给一个变量以便投入使用,&lt;/p&gt;
&lt;p&gt;例: &lt;code&gt;const level = useContext(LevelContext);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此后, 可以在该组件中使用 level 作为正常变量进行对应的操作&lt;/p&gt;
&lt;p&gt;最后, 在需要进行透传的组件中(上文子组件的父组件)中使用 level 作为 props, 并在定义组件时, 引入 LevelContext 并用其包裹子组件&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;import { LevelContext } from &amp;#39;./LevelContext.js&amp;#39;;

export default function Section({ level, children }) {
  return (
    &amp;lt;section className=&amp;quot;section&amp;quot;&amp;gt;
     &amp;lt;LevelContext value={level}&amp;gt; //传给子组件的值
        {children}
      &amp;lt;/LevelContext&amp;gt;
    &amp;lt;/section&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此后, context 便会在组件间进行透传(可以传到上文的两种组件中), 并会穿过中间层级的组件&lt;/p&gt;
&lt;ol start=&quot;31&quot;&gt;
&lt;li&gt;&lt;p&gt;ts 中, 可以使用 &lt;code&gt;:React.FC&amp;lt;{}&amp;gt;&lt;/code&gt; 快捷地为传入的 props 中的各项数据进行类型声明&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Object.keys(obj)&lt;/code&gt; 方法可以快速地得到 obj 的键名组成的数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;context 及 reducer 函数在多数时候可以使用 store 库进行代替, store 库中的状态更改时也会触发重新渲染&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;每次组件触发重新渲染时, 常规变量的值都会被重置, 想要保存变量的值, 应当使用 useState 或者 useRef&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数: useRef&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;const ref = useRef(0);&lt;/code&gt; 创建一个 ref, 括号中为提供的初始值&lt;/p&gt;
&lt;p&gt;然而, ref 返回的是一个对象 &lt;code&gt;{ current: 0  // 你向 useRef 传入的值 }&lt;/code&gt; 在组件中应当使用 ref.current 访问储存的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;ref 与 state 异同&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;ref&lt;/th&gt;
&lt;th&gt;state&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;useRef(initialValue)&lt;/code&gt;返回 &lt;code&gt;{ current: initialValue }&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;useState(initialValue)&lt;/code&gt; 返回 state 变量的当前值和一个 state 设置函数 ( &lt;code&gt;[value, setValue]&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;更改时不会触发重新渲染&lt;/td&gt;
&lt;td&gt;更改时触发重新渲染。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可变 —— 你可以在渲染过程之外修改和更新 &lt;code&gt;current&lt;/code&gt; 的值。&lt;/td&gt;
&lt;td&gt;“不可变” —— 你必须使用 state 设置函数来修改 state 变量，从而排队重新渲染。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;你不应在渲染期间读取（或写入） &lt;code&gt;current&lt;/code&gt; 值。&lt;/td&gt;
&lt;td&gt;你可以随时读取 state。但是，每次渲染都有自己不变的 state &lt;a href=&quot;https://zh-hans.react.dev/learn/state-as-a-snapshot&quot;&gt;快照&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;ref 可以被便利地更改: 不需要使用 set 函数&lt;/p&gt;
&lt;p&gt;ref &lt;strong&gt;不是快照&lt;/strong&gt;, state 则是, 例如在异步操作中, state 被提交后则固定, 而 ref 在操作执行前仍可以更改并将变化反应到结果上, 所以 ref 也常常被用于各种异步操作中&lt;/p&gt;
&lt;p&gt;ref &lt;strong&gt;不会&lt;/strong&gt;触发浏览器的重新渲染, 所以它不应当被使用在与 DOM 相关的变化中, 相反, 在一些频繁触发的操作中, 使用 ref 可以极大地优化性能: 例如: 制作秒表, 制作防抖函数中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;element.scrollIntoView()&lt;/code&gt; 方法将元素滚动到视野中, 可传入参数对象:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;        {
          behavior: &amp;#39;...&amp;#39;,
          block: &amp;#39;...&amp;#39;,
          inline: &amp;#39;...&amp;#39;
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;38&quot;&gt;
&lt;li&gt;&lt;p&gt;ref 在很多时候被用来控制 DOM , 处理一些 react 无法处理的 DOM 事件, 常见示例包括管理焦点、滚动位置或调用 React 未暴露的浏览器 API, 但是，如果尝试手动 &lt;strong&gt;修改&lt;/strong&gt; DOM，则可能会与 React 所做的更改发生冲突, &lt;strong&gt;尽量不要这么做&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要实现功能, 首先: &lt;code&gt;const myRef = useRef(null);&lt;/code&gt; 将 ref 设置为null&lt;/p&gt;
&lt;p&gt;之后, 将 DOM 绑定在 JSX 上: &lt;code&gt;&amp;lt;div ref={myRef}&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在 DOM 节点被创建时, React 会把对该节点的引用放入 &lt;code&gt;myRef.current&lt;/code&gt; , 然后便可以访问这个 DOM 元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;可以使用 ref 回调更精确地控制 ref: 即&lt;strong&gt;将函数传递给 &lt;code&gt;ref&lt;/code&gt; 属性&lt;/strong&gt;以控制 ref 在不同情况下的各种状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如同其他 props , ref 也可以被传给子元素, 便可以透过父元素控制子元素状态&lt;/p&gt;
&lt;p&gt;可以使用 &lt;code&gt;useImperativeHandle&lt;/code&gt; 控制父元素可以访问的子元素特性的范围&lt;/p&gt;
&lt;p&gt;配置: &lt;code&gt;useImperativeHandle(ref, createHandle, [deps])&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ref&lt;/code&gt;：传递给组件的 &lt;code&gt;ref&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;createHandle&lt;/code&gt;：返回一个对象，该对象就是暴露给父组件的实例值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[deps]&lt;/code&gt;：可选参数，是一个依赖数组，当依赖项发生变化时，&lt;code&gt;createHandle&lt;/code&gt; 会重新执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 flushSync 可以使 set state 函数不等待更新队列立刻更新 DOM&lt;/p&gt;
&lt;p&gt;配置: &lt;code&gt;flushSync(callback)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;callback&lt;/code&gt;：一个回调函数，在该函数中进行状态更新操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Effect&lt;/strong&gt; 是 React 范式中的一种脱围机制, 它&lt;strong&gt;允许你指定由渲染自身，而不是特定事件引起的副作用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Effect 在 &lt;a href=&quot;https://zh-hans.react.dev/learn/render-and-commit&quot;&gt;提交&lt;/a&gt; 结束后、页面更新后运行: 此时是将 React 组件与外部系统（如网络或第三方库）同步的最佳时机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Effect 的使用:&lt;/p&gt;
&lt;p&gt;导入 Effect 后 &lt;strong&gt;&lt;code&gt;( import { useEffect } from &amp;#39;react&amp;#39;)&lt;/code&gt;&lt;/strong&gt; , 在组件顶部进行调用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-jsx&quot;&gt;function MyComponent() {
 useEffect(() =&amp;gt; {
    // 每次渲染后都会执行此处的代码

  });

  return &amp;lt;div /&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单来讲, &lt;strong&gt;&lt;code&gt;useEffect&lt;/code&gt; 会“延迟”一段代码的运行，直到渲染结果反映在页面上&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;useEffect 还可以接收第二个参数: 依赖数组,&lt;/p&gt;
&lt;p&gt;当无依赖数组时: 在每次渲染后调用&lt;/p&gt;
&lt;p&gt;当存在依赖数组时, 需要将 Effect 中使用的参数放入其中, 否则会报错&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;当依赖数组为空时: 在组件挂载后调用(注意)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用正常的依赖数组时, 依赖数组中的 &lt;strong&gt;任意元素变化&lt;/strong&gt; 将调用 Effect (注意: Effect 为浅比较)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按需添加清理（cleanup）函数: 因为在每次渲染后都会调用 Effect , 所以 Effect 产生的副作用应当被及时进行清理&lt;/p&gt;
&lt;p&gt;可以在 Effect 中返回一个 &lt;strong&gt;清理（cleanup）函数&lt;/strong&gt;, React 会在每次 Effect 重新运行之前调用清理函数，并在组件卸载（被移除）时最后一次调用清理函数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded><dc:creator>youngestar-backyard</dc:creator><pubDate>Wed, 02 Apr 2025 16:00:00 GMT</pubDate></item></channel></rss>